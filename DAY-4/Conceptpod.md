A few things which will make your understanding on Kubernetes better, because I don't want to directly jump onto you and explain like you know what is a pod in Kubernetes and how to deploy a pod how to install your application, it will hardly take me 15 minutes to do that, but I will properly explaining the basics and then we will go with the demo. 
Okay, so that your fundamentals are clear. Firstly, we are moving from Docker to Kubernetes right I mean, we are moving our thing from container to container orchestration environment so in Kubernetes, the lowest level of deployment is a pod, okay. So in Kubernetes, you cannot directly deploy a container in Docker what you are doing is you are building a container and you are deploying a container right in Kubernetes. Also, we will use these containers that you have deployed in Docker because end of the day, whether it is Kubernetes or whether it is Docker, the end goal is to deploy your applications in containers, right? So that is the concept of containerization. What Kubernetes says is okay, don't deploy your application and container assets, but deploy to me as a pod know what is pod why we should deploy your container as a pod? Why can't you directly deploy as a container in Kubernetes as well? So this has to be a fundamental question. Right? Because once you start learning Kubernetes the very first thing that we'll see is people talk about pod. Now, if in Docker if you're installing your applications using containers, but you have to install in Kubernetes using pods, what is it and why is it different? Okay, so now, basically a pod is described, okay, in terms of definition a pod is described as a definition on or definition of how to run a container. 
Okay, so what does this mean? Let's say, in Docker, whenever you want to run a container, what you would do is basically you would say, Docker, run minus d, or minus T or minus id, followed by the name of the container, then what you would call the name of the image, then you would pass minus p to do some port mapping, then you would say minus V to do some mount volume volumes. Then if you have some network, you'd say minus hyphen F and network and you would pass the network details. So in Docker, you're basically passing all of these arguments to run a container right in command line, whereas in Kubernetes, what you will do is you will pass those specifications in the pod dot Yamo file, okay. So in Kubernetes, you basically have a proper or you basically have a concept that is similar to container but it abstracts the user defined commands in Pardot specification. So if it is confusing, don't worry about it. I'm going to explain it in a very clear way. So what you do in Kubernetes is you instead of container you will deploy a pod, okay? Now a pod can be a single container, or it can be multiple containers. I'll tell you why a pod can be multiple containers, what are the advantages but first, for now just go with a single container. Okay, so assume you're building a pod with one single container. What you will do is similar to Docker, kind of the report is also exactly like a Docker container. The only difference is when you have one single container The only difference is here. Instead of you using a command called Docker run, and then you pass all the different arguments, you will try to put all of them in a Yamo file. Okay. So inside of the Amyl file, you will say something like this API version is the one then you provide the name of this container, sorry of this port and all of these things, then you will provide a specification so inside the specification, you will provide all of the details of the container. Okay, so you have multiple containers option here and inside which you provide specification of your containers. 
So don't worry once you look into the definition or the YAML file of the body, you will understand okay, it is exactly similar to your container but the only thing is instead of command line you are trying to put everything in a Yamo file. That's the only difference now why Kubernetes has to deal with this complexity. You might ask me a question that Abishek if things are going well with Docker container, and you can deploy everything as a container in Docker platform, why Kubernetes has introduced this complexity, why you have to run things in Kubernetes using YAML files. So the thing is Kubernetes like I told you is an enterprise level platform and what it wants to do is it want to bring declarative capabilities. Okay. So or it want to build a standardization. So the thing is, you can put these YAML files okay in Kubernetes we do everything with the Amyl okay. So, whether it is pod resource, whether it is deployment resource, whether it is services, we are going to talk about all of these things in future, but everything will be written in YAML files only. Okay, so you have to master YAML files. You don't have to like you know, Maga how to write about the Amyl file, you don't have to muck up how to write a deployment Yamo file, don't worry about it. We have a bunch of examples. And everybody make use of these examples only like whether it's a senior DevOps engineer Juliet as everybody uses example from official Kubernetes documentation or from some samples, but the thing that I want to mention is you have to understand how YAML files are written. So only then you will become expert in Kubernetes because every day we deal with YAML files in Kubernetes okay. So, like I told you, pod is nothing but one or group of containers. So why it has to be one or group of containers. So most of the times a pod is a single container. But there are some cases where you have some, you know, sidecar containers, or you have some init containers. So, what are these things like these are the things that support your actual container. Just to give you an example, let's say you have a container okay? You have your application deployed in a container. And this wants to read some config files, or you know, this wants to read some user related files from another container. So in such cases, what we'll do is instead of creating two different pods in Kubernetes, you can put both of them in a single pod. And what pod says is if you put one or two containers or multiple containers inside a single pod, I will ensure that Kubernetes will ensure that both of the containers will have some advantages. So that's why you put one or group of containers inside a single pod when it is required. What are the advantages? So if you put a group of containers in a single pod, okay, let's say you have container a and container B, and if you put both of them in one single pod in Kubernetes, then Kubernetes will allow you shared networking. 
shared storage, okay, so this way, what happens is container a and container b inside a single pod can talk to each other using localhost. 
That means to say if container a wants to talk to container B port three 3000 So you can simply access using localhost 3000 Okay. So the application can be directly accessed and the information can be retrieved or if both of them wants to share some files, okay, so even in such cases, because both of them are in one single pod, they can share the files as well. So that is one of the reasons why people put multiple containers but it is a very rare case. The usual practice for this is to create some sidecar containers or init containers, which is an advanced topic, which I'll explain going ahead. When we talk about service mesh or when we talk about, you know, things like some advanced concept of Kubernetes. I will talk about why you put multiple containers inside a pod, but for now, if you understand that, there is a port and inside this part of Kubernetes, you have a container. So, container and pod. So basically what Kubernetes does is it allocates a cluster IP address to this pod, okay, and you can access the applications inside the container using this pod cluster IP address. So IP addresses are not generated for the containers but they are generated for the pods. No, don't worry or don't overthink the concept here because it is fairly simple. A pod is basically a wrapper that Kubernetes has created for a container to make the life of DevOps engineers easy. 
Because when we try to deal with containers, like hundreds of containers, 1000s of containers in production, if you have a proper like pod, which can define everything in a Yamo file, okay, which can say like if a developer can go to a git repository, or a DevOps engineer can go to a data repository and look for the pod or YAML file. He will understand everything about the container, okay. So this container is running on an application is running inside it on port 80. It has a volume volume monitor, then, you know, what is the networking of it or we will understand multiple details that you have for your Docker container. So Kubernetes has created a wrapper for it. Okay, so most of the cases when you're dealing with a pod, you deal with a single container and you know, you access the pod, or you access a container using the cluster IP address that Kubernetes gives per pod. So who is using this cluster IP address? If you watch the previous videos, cube proxy, is generating this cluster IP address Okay, perfect. So this is the concept of boarding Kubernetes. So very first application that we are going to deploy we are going to deploy as a pod. Okay, don't worry. We are going to when we do the demo, you will understand this even in a better way. But one more concept that I wanted to introduce here is you CTL what is due today so cube CTL is nothing but like for Docker whenever you are trying to run any commands. You have the Docker CLI Right? in Kubernetes you have something called as cube today. So cube CTL is command line for Kubernetes Okay, so what is it? It's a command line tool for Kubernetes. So you can directly interact with the Kubernetes clusters. Let's say you have a Kubernetes cluster and inside that you have 10 nodes. Okay, so to understand how many nodes are there inside your Kubernetes cluster, you can just use this new tickle command and say cube CTL. 
Get loads. 
Okay, so how do you understand these commands? What are the different options? I'll show you don't worry. So if you want to see how many pots are there, you can simply say cube CTL get pods, if you want to see how many deployments are there cube CTL get deployment. If you want to delete a deployment you want to create a deployment. So for such cases to interact with Kubernetes we have cube CTL. So today's class, we will first install cube CTL then we will create a Kubernetes cluster that is mini cube. Why we will create a mini cube Kubernetes cluster because the last lesson I told you, I showed you how to create a Kubernetes cluster on AWS using cops right for this you need to have some free credits on AWS. 
You can also run Eks or any other systems but for that you need some free credits. So if you don't want to spend on your Kubernetes cluster, you can learn them using a local Kubernetes cluster that is mini cube or patrias or kind or any Kubernetes cluster installation of all of them are fairly simple. Don't worry about the installation at all. But the only thing is when you use this local Kubernetes clusters they are not as equal as your full boon to when it is like full blown Kubernetes clusters. But for our demo purposes, or for our learning purposes, because we don't run huge applications. We are not running applications that are CPU and memory intensive. So even these clusters are fine. And we're not going to set up any high availability, all of these things at this point. So you can use mini cube so that you don't have to spend on your AWS. Okay, so first thing we will see is how to install cube CTL then we will see how to create a Kubernetes cluster on your local using mini cube. I have a complete video as well, where you can refer to this complete video. I'll share the link in the description if you find today's video is going fast with respect to installation. Don't worry, you can refer to this video. So cube CTL mini cube and then we will see how to deploy airport which is our first application on Kubernetes. 
Okay, here's the things clear tiller. Let me stop sharing here and let me proceed with the demo. 
So I stopped sharing. Then let me share my terminal okay. 
Just a second. Perfect. So now I have my terminal. 
Let me increase the font a bit. 
Perfect. So now you guys are able to see my terminal as well. Right. 